var map = L.map('map').fitWorld();

L.tileLayer('https://a.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
        '<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ',
    id: 'mapbox/streets-v11',
    tileSize: 512,
    zoomOffset: -1
}).addTo(map);

var lastKnownLocation = undefined;
var myMarker = undefined;

function onLocationFound(e) {
    if (lastKnownLocation != undefined && lastKnownLocation.lat === e.latlng.lat && lastKnownLocation.lng === e.latlng.lng) {
        return;
    }
    var radius = e.accuracy / 2;

    if (myMarker != undefined) {
        map.removeLayer(myMarker);
    }

    myMarker = L.marker(e.latlng).addTo(map)
        .bindPopup("You are within " + radius + " meters from this point").openPopup();
    //L.circle(e.latlng, radius).addTo(map);
    lastKnownLocation = e.latlng;
}

function onLocationError(e) {
   // alert(e.message);
}

map.on('locationfound', onLocationFound);
map.on('locationerror', onLocationError);
setInterval(
    function() {
        var setViewAgain = lastKnownLocation === undefined;
        map.locate({setView: setViewAgain, maxZoom: 16});
        console.log("Locate")
    }
,10000);

//query generated by https://overpass-turbo.eu/s/YR1
fetch("https://overpass-api.de/api/interpreter", {
  "headers": {
    "accept": "*/*",
    "accept-language": "en-GB,en-US;q=0.9,en;q=0.8,pl;q=0.7,es;q=0.6",
    "cache-control": "no-cache",
    "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
    "pragma": "no-cache",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "cross-site"
  },
  "referrer": "https://overpass-turbo.eu/",
  "referrerPolicy": "strict-origin-when-cross-origin",
  "body": "data=%2F*%0AThis+has+been+generated+by+the+overpass-turbo+wizard.%0AThe+original+search+was%3A%0A%E2%80%9Cbicycle%3Ddesignated%E2%80%9D%0A*%2F%0A%5Bout%3Ajson%5D%5Btimeout%3A25%5D%3B%0A%2F%2F+gather+results%0A(%0A++%2F%2F+query+part+for%3A+%E2%80%9Cbicycle%3Ddesignated%E2%80%9D%0A++node%5B%22bicycle%22%3D%22designated%22%5D(50.073832778452946%2C19.90473747253418%2C50.086115411999636%2C19.959540367126465)%3B%0A++way%5B%22bicycle%22%3D%22designated%22%5D(50.073832778452946%2C19.90473747253418%2C50.086115411999636%2C19.959540367126465)%3B%0A++relation%5B%22bicycle%22%3D%22designated%22%5D(50.073832778452946%2C19.90473747253418%2C50.086115411999636%2C19.959540367126465)%3B%0A)%3B%0A%2F%2F+print+results%0Aout+body%3B%0A%3E%3B%0Aout+skel+qt%3B",
  "method": "POST",
  "mode": "cors"
})
.then(response => response.json())
.then(data => data.elements)
.then(elements => {
    var ways = elements.filter(e => e.type === "way");
    var nodes =  new Map(elements.filter(e => e.type  === "node").map(n => {n.neighbours = new Set(); return n;}).map(n => [n.id, n]));

    ways.forEach(w => {

        var prevNode = undefined;
        w.nodes.forEach(n => {
            if (prevNode != undefined) {
                nodes.get(n).neighbours.add(prevNode);
                nodes.get(prevNode).neighbours.add(n);
                }
            prevNode = n;
            });

        var latlngs = w.nodes.map(n => nodes.get(n));
        L.polyline(latlngs, {color: 'red'}).addTo(map);
        });
    console.log(nodes);
    }
  );

